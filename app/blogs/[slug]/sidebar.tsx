"use client";

import { useEffect, useState, useRef, MouseEvent } from 'react'; // Import MouseEvent
import Link from 'next/link';

interface Heading { // Explicitly define the Heading type
  id: string;
  text: string;
  level: number;
}

// Function to apply and remove highlight class
const highlightElement = (id: string) => {
  const element = document.getElementById(id);
  if (element) {
    element.classList.add('heading-highlight');
    setTimeout(() => {
      element.classList.remove('heading-highlight');
    }, 1500); // Highlight duration: 1.5 seconds
  }
};

export const TableOfContents: React.FC = () => {
  const [headings, setHeadings] = useState<Heading[]>([]);
  const [activeId, setActiveId] = useState<string | null>(null);
  const observer = useRef<IntersectionObserver | null>(null);
  const scrollTimeout = useRef<NodeJS.Timeout | null>(null); // Ref to manage scroll timeout

  useEffect(() => {
    // Function to extract headings from the article content
    const extractHeadings = () => {
      const articleElement = document.querySelector('article'); // Target the main article container
      if (!articleElement) return;

      const headingElements = Array.from(
        articleElement.querySelectorAll('h2, h3, h4, h5, h6'), // Select all heading levels
      ) as HTMLElement[]; // Type assertion

      const extracted: Heading[] = headingElements
        .filter(heading => heading.id) // Ensure headings have IDs
        .map((heading) => ({
          id: heading.id, // Assumes headings have IDs generated by rehype-slug/rehype-autolink-headings
          text: heading.innerText,
          level: parseInt(heading.tagName.substring(1), 10),
        }));
      setHeadings(extracted);

      // Re-observe elements after headings are extracted/updated
      observer.current?.disconnect(); // Disconnect previous observer
      const headingElementsWithIds = document.querySelectorAll('article h2[id], article h3[id], article h4[id], article h5[id], article h6[id]');
      headingElementsWithIds.forEach((elem) => observer.current?.observe(elem));
    };


    // Debounce or throttle this if performance becomes an issue
    const timeoutId = setTimeout(extractHeadings, 100); // Delay slightly to ensure content is rendered

    // --- Intersection Observer for Active Heading ---
    observer.current = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            // Use timeout to avoid rapid activeId changes during scroll
            if (scrollTimeout.current) clearTimeout(scrollTimeout.current);
            scrollTimeout.current = setTimeout(() => {
              setActiveId(entry.target.id);
            }, 100); // Adjust delay as needed
          }
        });
      },
      { rootMargin: '-20% 0px -80% 0px' } // Adjust margins to highlight heading when it's near the top
    );

    // Initial observation setup (will be re-done in extractHeadings)
    // We call extractHeadings which handles observation

    return () => {
      clearTimeout(timeoutId);
      if (scrollTimeout.current) clearTimeout(scrollTimeout.current);
      observer.current?.disconnect();
    };
  }, []);

  // Handle smooth scrolling and highlight on click
  const handleClick = (e: MouseEvent<HTMLAnchorElement>, id: string) => {
    e.preventDefault();
    const element = document.getElementById(id);
    if (element) {
      // Calculate offset considering the fixed header height (adjust value as needed)
      const headerOffset = 100; // Approx height of your fixed header + some padding
      const elementPosition = element.getBoundingClientRect().top;
      const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

      window.scrollTo({
        top: offsetPosition
      });

      // Highlight after scrolling starts
      setTimeout(() => {
        highlightElement(id);
        // Manually set activeId after click for immediate feedback
        setActiveId(id);
      }, 300); // Delay highlight slightly to allow scroll to start
    }
  };

  // Helper function to scroll to top
  const scrollToTop = () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth',
    });
  };

  if (headings.length === 0) {
    return null; // Don't render sidebar if no headings found
  }

  return (
    // Ensure sidebar sticks to the top and doesn't overlap content
    <aside className="sticky top-24 hidden lg:block w-64 flex-shrink-0 ml-16 self-start">
      <nav>
        <h3 className="text-sm font-semibold text-zinc-900 mb-2 uppercase tracking-wider">On this page</h3>
        <ul>
          {headings.map((heading) => (
            <li
              key={heading.id}
              className="my-1"
              style={{ marginLeft: `${(heading.level - 2) * 1}rem` }}
            >
              <Link
                href={`#${heading.id}`}
                onClick={(e) => handleClick(e, heading.id)} // Add onClick handler
                className={`block text-sm transition-all duration-300 ease-in-out
                  ${activeId === heading.id
                    ? 'text-zinc-900'
                    : 'text-zinc-400 hover:text-zinc-900'}
                `}
              >
                {heading.text}
              </Link>
            </li>
          ))}
        </ul>
        {/* Scroll to top button */}
        <div className="mt-4 pt-4 border-t border-zinc-700">
          <button
            onClick={scrollToTop}
            className="text-sm text-zinc-600 hover:text-zinc-900 transition-colors duration-150 w-full text-left"
          >
            Scroll to top
          </button>
        </div>
      </nav>
    </aside>
  );
};
