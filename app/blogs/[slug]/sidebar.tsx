"use client";

import { useEffect, useState, useRef, MouseEvent } from 'react'; // Import MouseEvent
import Link from 'next/link';

interface Heading { // Explicitly define the Heading type
  id: string;
  text: string;
  level: number;
}

// Function to apply and remove highlight class
const highlightElement = (id: string) => {
  const element = document.getElementById(id);
  if (element) {
    element.classList.add('heading-highlight');
    setTimeout(() => {
      element.classList.remove('heading-highlight');
    }, 1500); // Highlight duration: 1.5 seconds
  }
};

export const TableOfContents: React.FC = () => {
  const [headings, setHeadings] = useState<Heading[]>([]);
  const [activeId, setActiveId] = useState<string | null>(null);
  const observer = useRef<IntersectionObserver | null>(null);
  const scrollTimeout = useRef<NodeJS.Timeout | null>(null); // Ref to manage scroll timeout

  useEffect(() => {
    // Function to extract headings from the article content
    const extractHeadings = () => {
      const articleElement = document.querySelector('article'); // Target the main article container
      if (!articleElement) return;

      const headingElements = Array.from(
        articleElement.querySelectorAll('h2, h3, h4, h5, h6'), // Select all heading levels
      ) as HTMLElement[]; // Type assertion

      const extracted: Heading[] = headingElements
        .filter(heading => heading.id) // Ensure headings have IDs
        .map((heading) => ({
          id: heading.id, // Assumes headings have IDs generated by rehype-slug/rehype-autolink-headings
          text: heading.innerText,
          level: parseInt(heading.tagName.substring(1), 10),
        }));
      setHeadings(extracted);

      // Re-observe elements after headings are extracted/updated
      observer.current?.disconnect(); // Disconnect previous observer
      const headingElementsWithIds = document.querySelectorAll('article h2[id], article h3[id], article h4[id], article h5[id], article h6[id]');
      headingElementsWithIds.forEach((elem) => observer.current?.observe(elem));
    };

    // Function to update active heading based on scroll position
    const updateActiveHeading = () => {
      const headingElements = Array.from(document.querySelectorAll('article h2[id], article h3[id], article h4[id], article h5[id], article h6[id]'));
      const headerOffset = 120; // Height of fixed header + some padding
      
      // Find the heading that's currently at the top of the viewport
      let currentActiveId = null;
      
      for (let i = headingElements.length - 1; i >= 0; i--) {
        const element = headingElements[i] as HTMLElement;
        const rect = element.getBoundingClientRect();
        
        if (rect.top <= headerOffset) {
          currentActiveId = element.id;
          break;
        }
      }
      
      // If we're at the very top of the page, select the first heading
      if (!currentActiveId && window.scrollY < 100 && headingElements.length > 0) {
        currentActiveId = (headingElements[0] as HTMLElement).id;
      }
      
      if (currentActiveId && currentActiveId !== activeId) {
        setActiveId(currentActiveId);
      }
    };

    // Throttled scroll handler
    let scrollTimeoutId: NodeJS.Timeout;
    const handleScroll = () => {
      clearTimeout(scrollTimeoutId);
      scrollTimeoutId = setTimeout(updateActiveHeading, 10);
    };

    // Debounce or throttle this if performance becomes an issue
    const timeoutId = setTimeout(extractHeadings, 100); // Delay slightly to ensure content is rendered

    // Add scroll listener for manual scroll tracking
    window.addEventListener('scroll', handleScroll, { passive: true });

    // --- Intersection Observer for Active Heading ---
    observer.current = new IntersectionObserver(
      (entries) => {
        // Clear any existing timeout
        if (scrollTimeout.current) clearTimeout(scrollTimeout.current);
        
        // Find the first visible heading that's closest to the top
        const visibleEntries = entries.filter(entry => entry.isIntersecting);
        
        if (visibleEntries.length > 0) {
          // Sort by distance from top (closest to top first)
          const sortedEntries = visibleEntries.sort((a, b) => {
            return a.boundingClientRect.top - b.boundingClientRect.top;
          });
          
          // Use timeout to avoid rapid activeId changes during scroll
          scrollTimeout.current = setTimeout(() => {
            setActiveId(sortedEntries[0].target.id);
          }, 50); // Reduced delay for more responsive updates
        } else {
          // If no headings are visible, find the heading that's just above the viewport
          const allHeadings = Array.from(document.querySelectorAll('article h2[id], article h3[id], article h4[id], article h5[id], article h6[id]'));
          let lastVisibleHeading = null;
          
          for (const heading of allHeadings) {
            const rect = heading.getBoundingClientRect();
            if (rect.top < 120) { // 120px is roughly the header height
              lastVisibleHeading = heading;
            } else {
              break;
            }
          }
          
          if (lastVisibleHeading) {
            scrollTimeout.current = setTimeout(() => {
              setActiveId(lastVisibleHeading.id);
            }, 50);
          }
        }
      },
      { 
        rootMargin: '-100px 0px -60% 0px', // Adjust margins for better detection
        threshold: [0, 0.1, 0.5, 1] // Multiple thresholds for better tracking
      }
    );

    // Initial observation setup (will be re-done in extractHeadings)
    // We call extractHeadings which handles observation

    return () => {
      clearTimeout(timeoutId);
      clearTimeout(scrollTimeoutId);
      if (scrollTimeout.current) clearTimeout(scrollTimeout.current);
      window.removeEventListener('scroll', handleScroll);
      observer.current?.disconnect();
    };
  }, [activeId]); // Add activeId to dependency array

  // Handle smooth scrolling and highlight on click
  const handleClick = (e: MouseEvent<HTMLAnchorElement>, id: string) => {
    e.preventDefault();
    const element = document.getElementById(id);
    if (element) {
      // Calculate offset considering the fixed header height (adjust value as needed)
      const headerOffset = 100; // Approx height of your fixed header + some padding
      const elementPosition = element.getBoundingClientRect().top;
      const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

      window.scrollTo({
        top: offsetPosition
      });

      // Highlight after scrolling starts
      setTimeout(() => {
        highlightElement(id);
        // Manually set activeId after click for immediate feedback
        setActiveId(id);
      }, 300); // Delay highlight slightly to allow scroll to start
    }
  };

  // Helper function to scroll to top
  const scrollToTop = () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth',
    });
  };

  if (headings.length === 0) {
    return null; // Don't render sidebar if no headings found
  }

  return (
    // Ensure sidebar sticks to the top and doesn't overlap content
    <aside className="sticky top-24 hidden lg:block w-64 flex-shrink-0 ml-16 self-start">
      {/* Add max-h and overflow-y-auto here */}
      <nav className="max-h-[calc(100vh-6rem-2rem)] overflow-y-auto pr-4"> {/* Adjust 6rem based on actual top offset (top-24) and 2rem for bottom padding */}
        <h3 className="text-sm font-semibold text-zinc-900 mb-2 uppercase tracking-wider">On this page</h3>
        <ul>
          {headings.map((heading) => (
            <li
              key={heading.id}
              className="my-2"
              style={{ marginLeft: `${(heading.level - 2) * 1}rem` }}
            >
              <Link
                href={`#${heading.id}`}
                onClick={(e) => handleClick(e, heading.id)} // Add onClick handler
                className={`block text-sm transition-all duration-300 ease-in-out pl-3 -ml-3
                  ${activeId === heading.id
                    ? 'text-zinc-900 border-zinc-900 font-medium'
                    : 'text-zinc-400 hover:text-zinc-900 border-transparent'}
                `}
              >
                {heading.text}
              </Link>
            </li>
          ))}
        </ul>
        {/* Scroll to top button */}
        <div className="mt-4 pt-4 border-t border-zinc-700">
          <button
            onClick={scrollToTop}
            className="text-sm text-zinc-600 hover:text-zinc-900 transition-colors duration-150 w-full text-left"
          >
            Scroll to top
          </button>
        </div>
      </nav>
    </aside>
  );
};
